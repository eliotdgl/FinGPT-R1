import random
import numpy as np
import gym
from gym import spaces
from sklearn.feature_extraction.text import TfidfVectorizer

class TextDataGenerator:
    def __init__(self, n_classes=3, samples_per_episode=100):
        self.n_classes = n_classes
        self.samples_per_episode = samples_per_episode
        self.templates_one_number = {
            #phrases with neutral sentiment with one number
            0: ["{} keeps the price target at {}.",
                "{} declares quarterly dividend of {} per Share, consistent with previous quarters" ],
            #phrases with negative sentiment with one number
            1: ["{} lost {} last quarter.",
                ],
            #phrases with positive sentiment with one number
            2: ["{} gained {} last quarter.", 
                ],
        }
        self.templates_two_numbers = {
            #phrases with neutral sentiment with two numbers
            0: [ "{} revenue was {} last quarter and is now {}.",
                 "{} went revenue from {} to {}.","{} growth was {} last quarter and is now {}.",
                 "Increase in total sales {} offset by decline in comparable store sales {}"],
            #phrases with negative sentiment with two numbers
            1: ["{} revenue went down of {} last quarter",
                "{} capitalization went from {} down to {}.", ],
            #phrases with positive sentiment with two numbers
            2: ["{} revenue went up of {} last quarter", 
                "{} capitalization went from {} up to {}."],
        }
        self.templates_stock_change ={
            
            1: ["{} {}(-{})"],
            2: ["{} {}(+{})"]

        }
        self.companies ={
        ["The company","Apple", "Google", "Microsoft", "Amazon", "Tesla","IBM", "Intel", "NVIDIA", "AMD", "Qualcomm","Samsung", "Sony", "LG", "Panasonic", "Toshiba"]
        }

    def generate_sentence(self, label):
        type_of_sentence = random.randint(0, 2)
        if type_of_sentence == 0:
            template = random.choice(self.templates_one_number[label])
            words = str(random.normal(50,1000))
        elif type_of_sentence == 1:
            template = random.choice(self.templates_two_numbers[label])
            words = random.sample(self.vocab[label], 2)
        else:
            template = random.choice(self.templates_stock_change[label])
            words = random.sample(self.vocab[label], 2)
        words = random.sample(self.vocab[label], 2)
        template = random.choice(self.templates[label])
        return template.format(*words)

    def generate_batch(self):
        texts = []
        labels = []
        for _ in range(self.samples_per_episode):
            label = random.randint(0, self.n_classes - 1)
            text = self.generate_sentence(label)
            texts.append(text)
            labels.append(label)
        return texts, labels

class TextLabelingEnv(gym.Env):
    def __init__(self, data_generator: TextDataGenerator):
        super(TextLabelingEnv, self).__init__()
        self.data_generator = data_generator
        self.vectorizer = TfidfVectorizer()
        self.current_index = 0
        self._prepare_data()

        # Gym spaces
        self.observation_space = spaces.Box(
            low=0, high=1, shape=(self.X.shape[1],), dtype=np.float32
        )
        self.action_space = spaces.Discrete(self.n_classes)

    def _prepare_data(self):
        self.texts, self.labels = self.data_generator.generate_batch()
        self.X = self.vectorizer.fit_transform(self.texts).toarray()
        self.n_classes = self.data_generator.n_classes
        self.current_index = 0

    def reset(self):
        self._prepare_data()
        return self.X[self.current_index]

    def step(self, action):
        true_label = self.labels[self.current_index]
        reward = 1 if action == true_label else 0
        self.current_index += 1
        done = self.current_index >= len(self.X)
        obs = (
            self.X[self.current_index]
            if not done
            else np.zeros_like(self.X[0], dtype=np.float32)
        )
        return obs, reward, done, {}

    def render(self, mode="human"):
        print(f"Text: {self.texts[self.current_index]}, Label: {self.labels[self.current_index]}")
