import random
import numpy as np
import gym
from gym import spaces
from sklearn.feature_extraction.text import TfidfVectorizer

class TextDataGenerator:
    def __init__(self, n_classes=2, samples_per_episode=100):
        self.n_classes = n_classes
        self.samples_per_episode = samples_per_episode
        self.templates = {
            0: [ "{} revenue was {} last quarter and is now {}.","{} went revenue from {} to {}.",
                "{} growth was {} last quarter and is now {}."],
            1: ["{} revenue went down of {} last quarter","{} lost {} last quarter.",
                "{} capitalization went from {} down to {}.", "{} {}(+{})"],
            2: ["{} revenue went up of {} last quarter","{} gained {} last quarter.", 
                "{} capitalization went from {} up to {}.","{} {}(-{})"],
        }
        self.numbers = {
        }
        self.companies ={
        ["The company","Apple", "Google", "Microsoft", "Amazon", "Tesla","IBM", "Intel", "NVIDIA", "AMD", "Qualcomm","Samsung", "Sony", "LG", "Panasonic", "Toshiba"]
        }

    def generate_sentence(self, label):
        words = random.sample(self.vocab[label], 2)
        template = random.choice(self.templates[label])
        return template.format(*words)

    def generate_batch(self):
        texts = []
        labels = []
        for _ in range(self.samples_per_episode):
            label = random.randint(0, self.n_classes - 1)
            text = self.generate_sentence(label)
            texts.append(text)
            labels.append(label)
        return texts, labels

class TextLabelingEnv(gym.Env):
    def __init__(self, data_generator: TextDataGenerator):
        super(TextLabelingEnv, self).__init__()
        self.data_generator = data_generator
        self.vectorizer = TfidfVectorizer()
        self.current_index = 0
        self._prepare_data()

        # Gym spaces
        self.observation_space = spaces.Box(
            low=0, high=1, shape=(self.X.shape[1],), dtype=np.float32
        )
        self.action_space = spaces.Discrete(self.n_classes)

    def _prepare_data(self):
        self.texts, self.labels = self.data_generator.generate_batch()
        self.X = self.vectorizer.fit_transform(self.texts).toarray()
        self.n_classes = self.data_generator.n_classes
        self.current_index = 0

    def reset(self):
        self._prepare_data()
        return self.X[self.current_index]

    def step(self, action):
        true_label = self.labels[self.current_index]
        reward = 1 if action == true_label else 0
        self.current_index += 1
        done = self.current_index >= len(self.X)
        obs = (
            self.X[self.current_index]
            if not done
            else np.zeros_like(self.X[0], dtype=np.float32)
        )
        return obs, reward, done, {}

    def render(self, mode="human"):
        print(f"Text: {self.texts[self.current_index]}, Label: {self.labels[self.current_index]}")
